use lookup_tables::*;
use serde::Deserialize;
use std::path::PathBuf;

const TOL: f64 = 1e-10;

#[derive(Deserialize)]
/// Deserialize data generated by `table1d_test_cases.py`
struct Inputs1D {
    /// Clamped test cases
    clamped: Vec<TestCase>,
}

impl Inputs1D {
    fn load() -> Self {
    let path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/lookup_table_1d_cases.json");
    let reader = std::fs::File::open(&path).unwrap();
    serde_json::from_reader(reader).unwrap()
    }
}

#[derive(Deserialize)]
struct TestCase {
    x: Vec<f64>,
    y: Vec<f64>,
    input: Vec<f64>,
    output: Vec<f64>,
}

#[test]
fn linear() {
    let cases = Inputs1D::load();

    for (idx, case) in cases.clamped.into_iter().enumerate() {
        println!("evaluating case index {idx}");

        dbg!(&case.x);
        dbg!(&case.y);

        let linear_table: LookupTable1D<Axis<f64, Linear, Clamp, Clamp>, f64> =
            LookupTable1D::new(case.x, Linear::default(), case.y).unwrap();

        for (input, output) in case.input.into_iter().zip(case.output.into_iter()) {
            println!("evaluating case input {input}");

            let linear_output = linear_table.lookup(&input);
            float_eq::assert_float_eq!(linear_output, output, abs <= TOL);
        }
    }
}

#[test]
fn binary() {
    let cases = Inputs1D::load();

    for (idx, case) in cases.clamped.into_iter().enumerate() {
        println!("evaluating case index {idx}");

        dbg!(&case.x);
        dbg!(&case.y);

        let binary_table: LookupTable1D<Axis<f64, Binary, Clamp, Clamp>, f64> =
            LookupTable1D::new(case.x, Binary::default(), case.y).unwrap();

        for (input, output) in case.input.into_iter().zip(case.output.into_iter()) {
            println!("evaluating case input {input}");

            let table_output = binary_table.lookup(&input);
            float_eq::assert_float_eq!(table_output, output, abs <= TOL);
        }
    }
}

#[test]
fn cached_linear_cell() {
    let cases = Inputs1D::load();

    for (idx, case) in cases.clamped.into_iter().enumerate() {
        println!("evaluating case index {idx}");

        dbg!(&case.x);
        dbg!(&case.y);

        let cached_linear_table: LookupTable1D<Axis<f64, CachedLinearCell, Clamp, Clamp>, f64> =
            LookupTable1D::new(case.x, CachedLinearCell::default(), case.y).unwrap();

        for (input, output) in case.input.into_iter().zip(case.output.into_iter()) {
            println!("evaluating case input {input}");

            let table_output = cached_linear_table.lookup(&input);
            float_eq::assert_float_eq!(table_output, output, abs <= TOL);
        }
    }
}
